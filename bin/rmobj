#!/usr/bin/env python

import boto.s3
import sys
import os
import logging
from boto.s3.connection import S3Connection
from boto.s3.connection import OrdinaryCallingFormat

## Load our local library functions
sys.path.insert(0, "%s/.." % os.path.dirname(sys.argv[0]))
import umobj
from umobj.utils import umobj_logging, umobj_init_keyboard_interrupt, \
    umobj_get_bucket_key_pair_from_string
from umobj.obj import Obj
from umobj.options import umobj_parser


if __name__ == "__main__":
    usage = 'Usage: %prog [OPTION] bucket[:key]+'
    description = 'Remove Bucket(s) and Object(s)'
    parser = umobj_parser(usage=usage, description=description)
    parser.add_recursive()
    parser.add_force()
    (options, args) = parser.parse_args()
    ## setup logging
    if options.debug:
        logging_level = logging.DEBUG
    elif options.verbose:
        logging_level = logging.INFO
    else:
        logging_level = logging.WARNING
    umobj_logging(logging_level)

    logging.info("Running %s" % sys.argv)

    if not Obj.connect(host=options.host,
                       port=options.port,
                       access_key=options.access_key,
                       secret_key=options.secret_key):
        logging.error('Unable to contact object store.')
        sys.exit(1)

    if len(args) == 0:
        parser.print_usage()
        sys.exit(1)

    for arg in args:
        bucket_name, key_name = umobj_get_bucket_key_pair_from_string(arg)

        try:
            bucket = Obj.conn.get_bucket(bucket_name)
        except boto.exception.S3ResponseError:
            logging.error("Bucket %s does not exist." % bucket_name)
            sys.exit(1)

        logging.info("Working on bucket %s" % bucket_name)

        if options.recursive:
            # removing all content inside bucket
            if not key_name:
                ans = raw_input(' Are you sure you want to remove all the ' +
                                'contents of the bucket \'%s\'? [yes/no] ' %
                                bucket.name).lower()
                if ans == 'yes':
                    for key in bucket.list():
                        logging.info("Deleting key %s" % key.name)
                        bucket.delete_key(key.name)
                else:
                    logging.info("Aborting recursive deletion of bucket %s" %
                                 bucket_name)
                    sys.exit(0)

                # removing the bucket itself
                ans = raw_input(' Do you want to remove the bucket \'%s\'?' %
                                bucket.name + ' [yes/no] ').lower()
                if ans == 'yes':
                    Obj.conn.delete_bucket(bucket.name)
                    logging.info("Deleting the bucket %s" % bucket_name)
                else:
                    logging.info("Not deleting the bucket %s" % bucket_name)
                sys.exit(0)

            # removing a directory
            if options.force:
                for key in bucket.list(prefix=key_name):
                    logging.info("Deleting key %s" % key.name)
                    bucket.delete_key(key.name)
            else:
                for key in bucket.list(prefix=key_name):
                    del_key_ans = raw_input('rmobj: delete \'%s\'? [y/n] ' %
                                            key.name).lower()
                    if del_key_ans != 'y':
                        continue
                    logging.info("Deleting key %s" % key.name)
                    bucket.delete_key(key.name)

        else:  # non-recursive
            if key_name is None:
                logging.error('Can not delete bucket %s, ' % bucket.name +
                              'please use recursive option.')
                sys.exit(1)
            elif key_name.endswith('/'):
                logging.error('Please use the recursive option to delete a ' +
                              'directory.')
            logging.info("Deleting key %s" % key_name)
            bucket.delete_key(key_name)
