#!/usr/bin/env python

import boto.s3
import sys
import math
import hashlib
import logging
import progressbar

from umobj.utils import umobj_logging, umobj_init_keyboard_interrupt, \
    umobj_get_bucket_key_pair_from_string
from umobj.obj import Obj
from umobj.options import umobj_parser


if __name__ == "__main__":
    umobj_init_keyboard_interrupt()

    description = 'List Object(s)'
    parser = umobj_parser(description=description)
    parser.add_s3path(number=1, help='BUCKET:KEY')
    args = parser.parse_args()
    ## setup logging
    if args.debug:
        logging_level = logging.DEBUG
    elif args.verbose:
        logging_level = logging.INFO
    else:
        logging_level = logging.WARNING
    umobj_logging(logging_level)

    logging.info("Running %s" % sys.argv)

    if not Obj.connect(host=args.host,
                       port=args.port,
                       access_key=args.access_key,
                       secret_key=args.secret_key):
        logging.error('Unable to contact object store.')
        sys.exit(1)

    S3PATH=args.S3PATH[0]
    bucket_name, key_name = umobj_get_bucket_key_pair_from_string(S3PATH)

    try:
        bucket = Obj.conn.get_bucket(bucket_name)
    except boto.exception.S3ResponseError, e:
        logging.error("Can not access bucket %s, %s." %
                      (bucket_name, e.error_code))
        sys.exit(1)
    key = bucket.get_key(key_name)
    if key is None:
        logging.error("Key %s does not exist in bucket %s" %
                      (key_name, bucket_name))
        sys.exit(1)
    md5 = hashlib.md5()
    size = key.size
    if size == 0:
        print md5.hexdigest()
        sys.exit()
    pbar = progressbar.ProgressBar(maxval=size)
    bytes_per_chunk = max(int(math.sqrt(5242880) * math.sqrt(size)),
                          5242880)
    chunk_amount = int(math.ceil(size / float(bytes_per_chunk)))
    logging.info("Bytes/Chunk : %d " % bytes_per_chunk +
                 "  Chunk Amount : %d" % chunk_amount)
    pbar.start()
    for i in range(chunk_amount):
        offset = i * bytes_per_chunk
        remaining_bytes = size - offset
        bytes = min([bytes_per_chunk, remaining_bytes])
        start_byte = offset
        end_byte = offset + bytes - 1
        logging.info("Processing bytes %d - %d" % (start_byte, end_byte))
        key_range = Obj.conn.make_request('GET',
                                          bucket=bucket_name,
                                          key=key_name,
                                          headers={'Range': "bytes=%d-%d" %
                                                   (start_byte, end_byte)})
        chunk_size = min((end_byte-start_byte), 32 * 1024 * 1024)
        while True:
            data = key_range.read(chunk_size)
            if data == "":
                break
            md5.update(data)
        pbar.update(end_byte)
    pbar.finish()
    print md5.hexdigest()
